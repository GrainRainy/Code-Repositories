
# 语法糖

这部分用于记录 $oi$ 中可能会用到的一些零散知识

## 数不清的 `log` 函数

`__lg()` 函数是一个非标准的函数，只在部分编译器中支持，它返回一个整数值，表示输入参数的二进制表示中最高位 $1$ 的位置（从 $0$ 开始计数）。例如， `__lg(8)` 将返回 $3$，因为 $8$ 的二进制表示是 $1000$，最高位 $1$ 在第 $3$ 位。

`log2()` 函数是 `C++11` 标准中提供的函数，它返回一个浮点数值，表示以 $2$ 为底的对数。例如，`log2(8)` 将返回 $3.0$，因为 $8$ 等于 $2$ 的 $3$ 次方。

## $nan$ & $inf$

### $nan$ meanings ： not a number

产生 $nan$ 的方式：

1. 对负数开方 $\sqrt{-1}$
2. 对负数求对数 $\log_2-1$
3. $0.0\ /\ 0.0$
4. $0\ *\ inf$
5. $inf\ /\ inf$
6. $inf\ -\ inf$
   
注：$0\ /\ 0$会产生操作异常；$0.0\ /\ 0.0$不会产生操作异常，而是会得到 $nan$

### inf means : infinity

无穷大的数，一般是超过浮点数的表示范围。
产生 $inf$ 的方式：

1. $1.0\ /\ 0.0$等于inf，$-1.0\ /\ 0.0$ 等于 $-inf$，$0.0\ +\ inf\ =\ inf$；
2. $1.0\ /\ inf$等于0.0

注：inf是可以与其他浮点数进行比较的，即可以参与<=、>+、==、!=等运算。


## 变量名重命名

使用 `using yourName = typeName` 对变量类型重定义名称，覆盖了 `typedef` 的全部用途，相比于 `typedef` 可读性更高，可定义模板（自适应类型），并且可以同时使用原变量名和新变量名

```cpp
template <typename T>
using vec = vector<T, vector<T>>;
using LL = long long;
```

## 标识符

使用标识符进行调试，可提高调试效率，快速 `禁用 / 启用` 不同功能的代码

```
#define DEBUG // 标识符 
```

### $Method\ 1 $

`#ifdef` 检查程序中是否有通过 `#define` 定义的对应标识符
如果有定义，就会执行截止到 `#endif` 的语句

```cpp
#ifdef DEBUG
 //do something
#endif
```

### $Method\ 2$

`#ifndef` 检查是否没有定义相应标识符，如没有定义，则执行截止到 `#endif` 的语句

```cpp
#ifndef DEBUG
 //do something
#endif
```

因此对于以上示例，当定义 `#define DEBUG` 时 $Method\ 1$ 中的语句会执行，而 $Method\ 2$ 中的语句不会执行. 当没有定义 `#define DEBUG` 时 $Method\ 1$ 中的语句不会执行，而 $Method\ 2$ 中的语句会执行. 

### 系统标识符

另外，当在不同操作系统下编译时，编译器会自动传入系统标识符，如：

1. `__WINDOWS__`（$Windows$ 下 gcc 编译器自动传入）
2. `__LINUX__`（$Linux$ 下 gcc 编译器自动传入）
3. `ONLINE_JUDGE`（在线 $OJ$ 编译器自动传入）

通过系统标识符，我们可以根据操作系统的不同选择不同语句，如自动选择未锁定 `getchar`：

```cpp
#ifdef __LINUX__
#define getchar() getchar_unlocked()
#define putchar(a) putchar_unlocked(a)
#endif

#ifdef __WINDOWS__
#define getchar() _getchar_nolock()
#define putchar(a) _putchar_nolock()
#endif
```