# $杂言录$

## 赛后总结

### [2023.03.16 - S2OJ 模拟赛](https://sjzezoj.com/contest/321)

1. $T1$ 花费时间太长，总觉得很快就能想出来 $T1$，**题目难度不一定升序排列**，不会可以先看后面的，$T3$ 多看看说不定就不会挂了。
2. $dp$ 假之后不要急着放弃，先想想：是否能通过加一维状态或多维护一些信息（时间复杂度可承受的情况下）解决？
3. 注意要写清楚题目中的限制条件，必要时不要吝啬 `if`，可以在纸上列出条件分类，记得带足草稿纸。
4. 永远不要相信赛时样例。手搓数据或暴力对拍都行，过样例不代表过这题。

### [2023.03.25 - S2OJ 模拟赛](https://sjzezoj.com/contest/324)

1. 某些图论题中一条边有可能走多次，因此仅从 边权 * 边数 < INT_MAX 是不足以断定是否爆 int 的。
2. 枚举排列计算方案数一般是指数级别的算法，而如果发现判定无解复杂度更低，可以尝试使用容斥原理计算。

### [2023.04.09 - S2OJ 模拟赛](https://sjzezoj.com/contest/326)

1. 最后十分钟检查的项目：
   1. 输入输出数量，尤其是样例 $n$ $m$ 相等时，要再看一遍 $n$ $m$ 是否写反
   2. 文件读写
   3. **数据范围**看数组是否开小了，即使是打了部分暴力也要把数组开全了(这次就是数组开小，不然就 $rank1$ 了 /kk)
   4. LL!! LL!! LL!! LL!! LL!! LL!!

### [2023.04.16 - 洛谷 模拟赛](https://www.luogu.com.cn/contest/106954)

1. 黄色贪心竟然没想出来，以为这是个反悔贪心，实际上按一个信息排序就好了。有时候贪心要大胆猜结论，并且写贪心是对思维很好的锻炼，以后要多写。
2. 思维陷入困境时可以先把暴力打完，并且检查数据范围和 LL（竟然又因为 LL 挂分了

### [2023.05.13 - 图灵杯](https://contest.xinyoudui.com/contest/92#/ProblemList)

1. 想到做法就去写，不要等 —— T2分层图
2. $dfs$ 剪枝时间复杂度很玄学，很容易写挂，如果有不用递归的写法就换，比如枚举序列前几项 —— T1 $25\ pts$

### [2023.05.21 - S2OJ 模拟赛](https://sjzezoj.com/contest/331)

1. T1 暴露出一些问题：对经典套路不熟悉，比如 $O(n)$ 求区间和 / 积，可以通过预处理前后缀和 / 积解决，也可以除以前一个数，乘后一个数。赛时写了假 $O(n)$ 递推，因为有个逆元的 $logn$，然而题目不保证模数为质数。所以在相同时间复杂度下线段树维护区间积能过模数不为质数的情况
2. T3 超水数学题竟然没想出来？$N \leqslant 10^{14}$ 很明显枚举因数的提示
3. T4 也许不显式建图也能解决图论问题，讨论一条边是否连，用并查集维护节点所在连通块即可

### [2023.06.10 - 洛谷 模拟赛](https://www.luogu.com.cn/contest/113294)

1. 发现在写矩形图的时候 $n$, $m$ 很容易写错，一顺手 $m$ 就写成 $n$ 了，一定要耐下心来多检查几遍。
2. 不要自己给题目加条件，比如两者的大小关系。除数和模数都不一定比原数小。写了拍都没拍出来... 就是因为自己提前预定的两者的大小关系。也算读题失误。

### [2023.06.11 - S2OJ 模拟赛](https://sjzezoj.com/contest/335)

1. 状压 $dp$ 搜图记得清空图，如果同时状压两层（比如一行一列），记得在两个状态都枚举完之后再清空，否则会 [覆盖上面枚举的信息](https://www.luogu.com.cn/record/112527765)。
2. 二维转一维的映射，二维下标从 $1$ 开始不太好写，从 $0$ 开始写好很多. 

### [2023.06.18 - S2OJ 模拟赛](https://sjzezoj.com/contest/347)

1. T2 分解阶乘的质因数比较，赛时降智竟然用了 $O(n)$ 枚举：`	while (!check()) divb(++ mul);`，事实上按照因数枚举，一个阶乘中含有的质因数个数可以按下面这样计算：
   ```cpp
		tmpCnt = 0;
		for (int j = i; j <= u; j *= i) {
			tmpCnt += u / j;
			if (tmpCnt >= stk[i]) break;
		}
		if (tmpCnt < stk[i]) return false;
   ```
   就可以进行二分，时间复杂度就对了。算是一个没想出来的小 $Trick$。

### [2023.06.24 - 洛谷 kb 个人公开赛](https://www.luogu.com.cn/contest/107029)

1. T3 - dfs 能加记搜的位置一定要加（100pts -> 35pts）

### [2023.06.27 - Codeforces Round 834 (Div. 3) VP](https://codeforces.com/contest/1759)

1. 小清新的数学题有时候从因数角度考虑会豁然开朗
2. 多测一定要等所有数据读入完后再判无解




******


## 练习总结

### 一些有用的 $Trick$

#### 标准分解式求因数个数

若一个数 $A$ 满足：

$$A = p_1^{a_1} \times p_1^{a_1} \times p_2^{a_2} \cdots p_k^{a_k}$$

则 $A$ 的因数个数为 $\prod \limits_{i = 1}^{k} (a_i + 1)$

#### [六边形图转化](https://www.luogu.com.cn/problem/P5458)

将六边形的三元组坐标 $(x, y, z)$ 转化为矩形图坐标 $(x - z, y - z)$

#### [求序列定长连续子段积](https://sjzezoj.com/problem/779)

##### 三种解决方案：

1. 预处理每个数逆元，时间复杂度 $O(n \cdot logn)$
2. 线段树，时间复杂度 $O(n \cdot logn)$
3. 分块，预处理各块前后缀积，$O(1)$ 查询，时间复杂度 $O(n)$

### 掉过的坑

1. 判断下标合理性要在调用数组之前，如

   `if (check(t * 2) and dist[t * 2] == -1)`

   要先 $check()$ 再 $dist[]$ ，受短路运算符影响，当第一个条件不成立时不会执行 $dist[]$，防止 $RE$

2. 溢出可能会在这些位置暗杀你：
   1. 对 LL 变量操作的函数，参与运算的参数不是 LL 
   2. 返回值是 LL 的函数，返回的参数不是 LL
   3. 返回值是运算式的函数，运算过程中爆 int 

3. 写 $ST$ 表的时候记得卡好两维范围，不然会 [$\color{purple}RE$](https://sjzezoj.com/submission/73187) 很惨。

   $i$ 需要 `i + (1 << k) - 1 <= n` 不能无脑 `<= n`
   
   $k$ 在开数组时记得多开几个 `int st[N][K + 10]`，不然 `for (int k = 0; k <= K; k ++)` 会越界
   
4. 矩形图 $n$ $m$ 范围不同时记得特殊判定，不要写出类似 `2 * n` 这样的 [$\tt \color{red}sb$](https://atcoder.jp/contests/abc293/submissions/39631266) 错误。同时注意观察 $n$ $m$ 是否同阶，保证复杂度正确

5. 遍历邻接表时临时变量很多，注意不要写串，$nxt$ 无实际意义，修改时需要修改 $to$

6. 常见的厌氧代码基本都是是函数不写返回值导致的

7. 建两张图而共用一个结构体数组 `edge` 时，不能另外使用 `idxb` 作指针，因为是连续向后存储的，想清楚了

8. 当使用 `tarjan` + `topsort` 求特定一点出发的 最长 / 最短 路时记得特判图的连通性，不连通的点不连边，否则 `indg` 会出错。具体地，特判一下 `if(!id[i]) continue` 即可，否则 [$\color{red}WA\ *\ 2$](https://www.luogu.com.cn/record/105655542).

9.  傻逼 `Dev-cpp` 会自动补全缺失的头文件，赛时用 `bits/stdc++.h` 保险

10. 数组越界时用于向后推的下标有可能从 $MaxLen$ 变为 $1$，如 `nums[50]; nums[++ top]`  当 `top = 49` 再 `top ++`，$top$ 为 $1$ 

11. 按你的习惯，字符串读入会用 `cin.tie(0)` `cout.tie(0)`，注意不能与 `getchar()` 或 `scanf` 一起使用，已经要检查几遍。如果先写的 `scanf` 后来又加去流，真的很容易挂.

12. 状压 dp 记得初始化单个物品选择的价值.

13. 线段树 `Query` 查询返回 $sum$ 时直接返回即可，不要加上 / 乘上 懒标记，懒标记已经对当前区间作用过了

14. 线段树需要取模时注意一定要模全，比如 `PushUp` 也要模

15. 仔细想好[树剖节点的值到底应该加减还是赋值](https://www.luogu.com.cn/record/110727436)

16. 期望递推式记得把未知数放在同一侧，系数化为 $1$，否则会因为转移顺序的问题而 $WA$

17. 当给定序列递推式时，如果要取模，注意递推再取模和取模再递推是[不一样的](https://www.luogu.com.cn/record/111077176)

18. 树剖如果单点修改，输入修改点 $u$，由于直接调用线段树修改函数，因此需要修改 `dfn[u]`

19. 树上差分如果使用树剖 $lca$，记得将根节点的父节点设为 $0$，否则会 $WA$ ——— 雨天的尾巴

20. $dsu\ on\ tree$ 第一次循环枚举记得[判掉重儿子](https://codeforces.com/contest/208/submission/208161314)，否则时间复杂度会假

21. $AC$ 自动机遍历 $Trie$ 树的指针 $p$ 记得初始化 $=0$，否则本地调不出来，交上去 $RE$.

22. 模意义下减法减完后记得 `x = (x % MOD + MOD) % MOD;` 防止出现负数. (错了两次...)

23. 0xcfcfcfcf 在 long long 类型下不为负无穷，应使用 0xcfcfcfcfcfcfcfcf 

24. 矩阵快速幂记得初始化答案矩阵为对角矩阵

25. `double` 类型在数很大的时候直接 `cout` 是科学计数法，如 $7.6402e+011$

26. `for (int i = 1, res = 0; i <= n; ++ i) {` 循环的第一个参数位置赋值不是每一个循环开始都为 `res` 赋值

27. 线段树中和 `mid` 同时定义的求区间和的临时变量 `res` 一定要记得初始化为 $0$

28. 一定要检查有返回值的函数是否返回了值。不开 `-O2` 也许返回 $0$（false），但开了 `-O2` 一定 RE

29. 可持久化线段树开空间时一定要记得初始的 `2n`，线段树总空间开到 `2n + nlogn`

30. 强制在线的答案变量 $\text{lastans}$ 要记得初始化为 $0$ 

31. 优先队列为空时取队头会 RE 

32. stl 容器多测记得清空

33. !a & 1 和 !(a & 1) 



