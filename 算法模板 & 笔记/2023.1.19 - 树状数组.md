# 树状数组 $Binary\ Index\ Tree$

空间复杂度 $O(n)$

## 模板

### 修改

```cpp
void modify(int pos, int val) {
    for (; pos <= n; pos += lowbit(pos))
        tr[pos] += val;
}
```

### 查询 $l \sim r$ 的区间和

```cpp
int query(int x) {
    int ans = 0;
    for (; x; x -= lowbit(x)) ans += tr[x];
    return ans;
}
int ans = query(r) - query(l - 1);
// 前缀和处理 
```

### 维护区间加，单点查询

转化为存储差分数组即可


## 经典模型

### 维护区间不同数的个数：[HH的项链](https://www.luogu.com.cn/problem/P1972)

考虑到不同数的贡献，钦定最右侧的数具有贡献，将其他数的贡献删除，因此离线询问，树状数组维护前缀和即可

```cpp
int p = 1;
for (int i = 1; i <= m; ++ i) {
   for (int j = p; j <= q[i].r; ++ j) {
      if (pos[a[j]]) modify(pos[a[j]], -1);
      pos[a[j]] = j, modify(j, 1);
   }
   p = q[i].r + 1;
   ans[q[i].id] = query(q[i].r) - query(q[i].l - 1);
}
```