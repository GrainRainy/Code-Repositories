---
title: 树链剖分 | 学习笔记
date: 2022-10-14 17:09:19
categories: 数据结构
tags: 学习笔记
author: GrainRain
cover: https://pic.imgdb.cn/item/63ba7febbe43e0d30ed59769.jpg
---

# 树链剖分 

$Tree\ Chain\ Partitioning$

初始化复杂度 $O(n \cdot logn)$
询问复杂度 $O(q \cdot log^2n)$
常数较小

```cpp
int dep[N], fa[N], nw[N], siz[N], hs[N];
int stamp, dfn[N], top[N];
// top refers to the top point of the chain 
// Note: especially refers to the heavy son 
// cutting trees 

struct SegmentTree {
    int l, r;
    LL sum, tag;

    #define l(x) tr[x].l
    #define r(x) tr[x].r
    #define sum(x) tr[x].sum
    #define tag(x) tr[x].tag
}tr[N << 2];

inline void add(int a, int b) {
    edge[++ idx].nxt = head[a];
    edge[head[a] = idx].to = b;
}

void dfs1(int u, int father) {
	dep[u] = dep[father] + 1, fa[u] = father, siz[u] = 1;
	for (int i = head[u]; ~i; i = edge[i].nxt) {
		int j = edge[i].to;
		if (j == father) continue;
		dfs1(j, u);
		siz[u] += siz[j];
		if (siz[j] > siz[hs[u]]) hs[u] = j;
	}
}

void dfs(int u, int t) {
	dfn[u] = ++ stamp, nw[stamp] = w[u], top[u] = t;
	if (!hs[u]) return;
	dfs(hs[u], t);
	for (int i = head[u], j; ~i; i = edge[i].nxt) {
		j = edge[i].to;
		if (!top[j]) dfs(j, j);
	}
}

/*** Segment Tree ***/
void PushUp(int u) {
    sum(u) = sum(lson) + sum(rson);
}

void PushDown(int u) {
    if (tag(u)) {
        sum(lson) += tag(u) * (r(lson) - l(lson) + 1);
        tag(lson) += tag(u);
        sum(rson) += tag(u) * (r(rson) - l(rson) + 1);
        tag(rson) += tag(u);
        tag(u) = 0;
    }
}

void build(int u, int l, int r) {
    tr[u] = {l, r, nw[r], 0};
    if (l == r) return;
    int mid = l + r >> 1;
    build(lson, l, mid), build(rson, mid + 1, r);
    PushUp(u);
}

void modify(int u, int l, int r, int k) {
    if (l > r(u) or r < l(u)) return;
    if (l <= l(u) and r >= r(u)) {
        sum(u) += (r(u) - l(u) + 1) * k;
        tag(u) += k;
        return;
    }
    PushDown(u);
    modify(lson, l, r, k);
    modify(rson, l, r, k);
    PushUp(u);
}

LL query(LL u, LL l, LL r) {
	if (l > r(u) or  r(u) < l) return 0;
	if (l <= l(u) and r >= r(u)) return sum(u);
	PushDown(u);
	return query(lson, l, r) + query(rson, l, r);
}

/*** Cutting Heavy Chains ***/

void ModifyPath(int u, int v, int k) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        modify(1, dfn[top[u]], dfn[u], k);
        u = fa[top[u]];
    }
    if (dep[u] < dep[v]) swap(u, v);
    modify(1, dfn[v], dfn[u], k);
}

LL QueryPath(int u, int v) {
    LL res = 0;
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res += query(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    } 
    if (dep[u] < dep[v]) swap(u, v);
    res += query(1, dfn[v], dfn[u]);
    return res;
}

inline void ModifyTree(int u, int k) {
    return modify(1, dfn[u], dfn[u] + siz[u] - 1, k), void();
}

inline LL QueryTree(int u) {
    return query(1, dfn[u], dfn[u] + siz[u] - 1);
}
```

除此之外，当需要对边权进行处理时，仅需要将一条边的边权下放至深度较深的点，作为点权处理，跳过修改两点的 $lca$ 即可。

具体地，在 $dfs1$ 中先将输入的边权 `edge[i].w` 赋给连向的点 $j$：`tmpw[j] = edge[i].w;`。再在 $dfs2$ 中为线段树节点赋值 `nw[dfn[u]] = tmpw[u]`

因此 `while` 循环以内的修改和查询正常操作，循环之外的点需要进行以下操作：

```cpp
modify(1, dfn[v] + 1, dfn[u], k); // 不对 lca 进行修改和查询 
query(1, dfn[v] + 1, dfn[u]);
```

注意：循环内的 `modify` 与 `query` 函数不做更改

## 经典模型

### 树上 $k$ 级祖先：[树上 $k$ 级祖先](https://www.luogu.com.cn/problem/P5903)：

重链剖分，倍增跳

```cpp
int find(int x, int k) {
	while (k >= dfn[x] - dfn[top[x]] + 1 and x != root) {
		k -= dfn[x] - dfn[top[x]] + 1;
		x = fa[top[x]];
	}
	return id[dfn[x] - k];
}
```
