# $杂言录$

## 赛后总结

### [2023.3.16 - S2OJ 模拟赛](https://sjzezoj.com/contest/321)

1. $T1$ 花费时间太长，总觉得很快就能想出来 $T1$，**题目难度不一定升序排列！！**，不会可以先看后面的，$T3$ 多看看说不定就不会挂了。
2. $dp$ 假之后不要急着放弃，先想想：是否能通过加一维状态或多维护一些信息（时间复杂度可承受的情况下）解决？
3. 注意要写清楚题目中的限制条件，必要时不要吝啬 `if`，可以在纸上列出条件分类，记得带足草稿纸！
4. 永远不要相信赛时样例！手搓数据或暴力对拍都行，过样例不代表过这题。

### [2023.3.25 - S2OJ 模拟赛](https://sjzezoj.com/contest/324)

1. 图论题中一条边有可能走多次，因此仅从 边权 * 边数 < INT_MAX 是不足以断定是否爆 int 的，开 LL 保险
2. 枚举排列计算方案数一般是指数级别的算法，而如果发现判定无解复杂度更低，可以尝试使用容斥原理计算

### [2023.4.9 - S2OJ 模拟赛](https://sjzezoj.com/contest/326)

1. 最后十分钟检查的项目：
   1. 输入输出数量，尤其是样例 $n$ $m$ 相等时，要再看一遍 $n$ $m$ 是否写反
   2. 文件读写
   3. **数据范围**看数组是否开小了，即使是打了部分暴力也要把数组开全了(这次就是数组开小，不然就 $rank1$ 了 /kk)
   4. LL!! LL!! LL!! LL!! LL!! LL!!

### [2023.4.16 - 洛谷 模拟赛](https://www.luogu.com.cn/contest/106954#problems)

1. 黄色贪心竟然没想出来，以为这是个反悔贪心，实际上按一个信息排序就好了。有时候贪心要大胆猜结论，并且写贪心是对思维很好的锻炼，以后要多写。
2. 思维陷入困境时可以先把暴力打完，并且检查数据范围和 LL（竟然又因为 LL 挂分了

### [2023.5.13 - 图灵杯](https://contest.xinyoudui.com/contest/92#/ProblemList)

1. 想到做法就去写，不要等 —— T2分层图
2. $dfs$ 剪枝时间复杂度很玄学，很容易写挂，如果有不用递归的写法就换，比如枚举序列前几项 —— T1 $25\ pts$

### [2023.5.21 - S2OJ 模拟赛](https://sjzezoj.com/contest/331)

1. T1 暴露出一些问题：对经典套路不熟悉，比如 $O(n)$ 求区间和 / 积，可以通过预处理前后缀和 / 积解决，也可以除以前一个数，乘后一个数，但当模数不为质数时就寄了。赛时写了假 $O(n)$ 递推，因为有个逆元的 $logn$，然而题目不保证模数为质数。所以在相同时间复杂度下线段树维护区间积能过模数不为质数的情况
2. T3 超水数学题竟然没想出来？$N \leqslant 10^{14}$ 很明显枚举因数的提示
3. T4 也许不显式建图也能解决图论问题，讨论一条边是否连，用并查集维护节点所在连通块即可

### [2023.6.10 - 洛谷 模拟赛](https://www.luogu.com.cn/contest/113294#problems)

1. 发现在写矩形图的时候 $n$, $m$ 很容易写错，一顺手 $m$ 就写成 $n$ 了，一定要耐下心来多检查几遍。
2. 不要自己给题目加条件，比如两者的大小关系。除数和模数都不一定比原数小。写了拍都没拍出来...就是因为自己提前预定的两者的大小关系。也算读题失误。

### [2023.6.11 - S2OJ 模拟赛](https://sjzezoj.com/contest/335)

1. 状压 $dp$ 搜图记得清空图，如果同时状压两层（比如一行一列），记得在两个状态都枚举完之后再清空，否则会 [覆盖上面枚举的信息](https://www.luogu.com.cn/record/112527765)。
2. 二维转一维的映射，二维下标从 $1$ 开始不太好写，从 $0$ 开始写好很多. 

### [2023.6.18 - S2OJ 模拟赛](https://sjzezoj.com/contest/347)

1. T2 分解阶乘的质因数比较，赛时降智竟然用了 $O(n)$ 枚举：`	while (!check()) divb(++ mul);`，事实上按照因数枚举，一个阶乘中含有的质因数个数可以按下面这样计算：
   ```cpp
		tmpCnt = 0;
		for (int j = i; j <= u; j *= i) {
			tmpCnt += u / j;
			if (tmpCnt >= stk[i]) break;
		}
		if (tmpCnt < stk[i]) return false;
   ```
   就可以进行二分，时间复杂度就对了。算是一个没想出来的小 $Trick$。

******


## 练习总结

### 一些有用的 $Trick$

#### 标准分解式求因数个数

若一个数 $A$ 满足：

$$A = p_1^{a_1} \times p_1^{a_1} \times p_2^{a_2} \cdots p_k^{a_k}$$

则 $A$ 的因数个数为 $\prod \limits_{i = 1}^{k} (a_i + 1)$

### 六边形图转化

将六边形的三元组坐标 $(x, y, z)$ 转化为矩形图坐标 $(x - z, y - z)$



*******


### 掉过的坑

1. 判断下标合理性要在调用数组之前，如

   `if (check(t * 2) and dist[t * 2] == -1)`

   要先 $check()$ 再 $dist[]$ ，受短路运算符影响，当第一个条件不成立时不会执行 $dist[]$，防止 $RE$

2. $LL!!$ 溢出可能会在这些位置暗杀你：
   1. 对 $LL$ 变量操作的函数，参与运算的参数不是 $LL$ 
   2. 返回值是 $LL$ 的函数，返回的参数不是 $LL$
   3. 返回值是运算式的函数，运算过程中爆 $int$ 

3. 写 $ST$ 表的时候记得卡好两维范围，不然会 [$\color{purple}RE$](https://sjzezoj.com/submission/73187) 很惨。

   $i$ 需要 `i + (1 << k) - 1 <= n` 不能无脑 `<= n`
   
   $k$ 在开数组时记得多开几个 `int st[N][K + 10]`，不然 `for (int k = 0; k <= K; k ++)` 会越界
   
4. 矩形图 $n$ $m$ 范围不同时记得特殊判定，不要写出类似 `2 * n` 这样的 [$\tt \color{red}sb$](https://atcoder.jp/contests/abc293/submissions/39631266) 错误。同时注意观察 $n$ $m$ 是否同阶，保证复杂度正确

5. 遍历邻接表时临时变量很多，注意不要写串，$nxt$ 无实际意义，修改时需要修改 $to$

6. 常见的厌氧代码基本都是是函数不写返回值导致的

7. 建两张图而共用一个结构体数组 `edge` 时，不能另外使用 `idxb` 作指针，因为是连续向后存储的，想清楚了

8. 当使用 `tarjan` + `topsort` 求特定一点出发的 最长 / 最短 路时记得特判图的连通性，不连通的点不连边，否则 `indg` 会出错。具体地，特判一下 `if(!id[i]) continue` 即可，否则 [$\color{red}WA\ *\ 2$](https://www.luogu.com.cn/record/105655542).

9.  傻逼 `Dev-cpp` 会自动补全缺失的头文件，赛时用 `bits/stdc++.h` 保险

10. 数组越界时用于向后推的下标有可能从 $MaxLen$ 变为 $1$，如 `nums[50]; nums[++ top]`  当 `top = 49` 再 `top ++`，$top$ 为 $1$ 

11. 按你的习惯，字符串读入会用 `cin.tie(0)` `cout.tie(0)`，注意不能与 `getchar()` 或 `scanf` 一起使用，已经要检查几遍。如果先写的 `scanf` 后来又加去流，真的很容易挂.

12. 状压 dp 记得初始化单个物品选择的价值.

13. 线段树 `Query` 查询返回 $sum$ 时直接返回即可，不要加上 / 乘上 懒标记，懒标记已经对当前区间作用过了

14. 线段树需要取模时注意一定要模全，比如 `PushUp` 也要模

15. 仔细想好[树剖节点的值到底应该加减还是赋值](https://www.luogu.com.cn/record/110727436)

16. 期望递推式记得把未知数放在同一侧，系数化为 $1$，否则会因为转移顺序的问题而 $WA$

17. 当给定序列递推式时，如果要取模，注意递推再取模和取模再递推是[不一样的](https://www.luogu.com.cn/record/111077176)

18. 树剖如果单点修改，输入修改点 $u$，由于直接调用线段树修改函数，因此需要修改 `dfn[u]`

19. 树上差分如果使用树剖 $lca$，记得将根节点的父节点设为 $0$，否则会 $WA$ ——— 雨天的尾巴

20. $dsu\ on\ tree$ 第一次循环枚举记得[判掉重儿子](https://codeforces.com/contest/208/submission/208161314)，否则时间复杂度会由 $O(n \cdot logn)$ 变成 $O(2^n)$ 

21. $AC$ 自动机遍历 $Trie$ 树的指针 $p$ 记得初始化 $=0$，否则本地调不出来，交上去 $RE$.

22. 模意义下减法减完后记得 `x = (x % MOD + MOD) % MOD;` 防止出现负数. 

23. 0xcfcfcfcf 在 long long 类型下不为负无穷. 

24. 矩阵快速幂记得初始化答案矩阵为对角矩阵

25. `double` 类型在数很大的时候直接 `cout` 是科学计数法，如 $7.6402e+011$


## 碎念

这部分用于记录 $oi$ 中可能会用到的一些零散知识

### 数不清的 `log` 函数

`__lg()` 函数是一个非标准的函数，只在部分编译器中支持，它返回一个整数值，表示输入参数的二进制表示中最高位 $1$ 的位置（从 $0$ 开始计数）。例如， `__lg(8)` 将返回 $3$，因为 $8$ 的二进制表示是 $1000$，最高位 $1$ 在第 $3$ 位。

`log2()` 函数是 `C++11` 标准中提供的函数，它返回一个浮点数值，表示以 $2$ 为底的对数。例如，`log2(8)` 将返回 $3.0$，因为 $8$ 等于 $2$ 的 $3$ 次方。

### $nan$ & $inf$

#### $nan$ meanings ： not a number

产生 $nan$ 的方式：

1. 对负数开方 $\sqrt{-1}$
2. 对负数求对数 $\log_2-1$
3. $0.0\ /\ 0.0$
4. $0\ *\ inf$
5. $inf\ /\ inf$
6. $inf\ -\ inf$
   
注：$0\ /\ 0$会产生操作异常；$0.0\ /\ 0.0$不会产生操作异常，而是会得到 $nan$

#### inf means : infinity

无穷大的数，一般是超过浮点数的表示范围。
产生 $inf$ 的方式：

1. $1.0\ /\ 0.0$等于inf，$-1.0\ /\ 0.0$ 等于 $-inf$，$0.0\ +\ inf\ =\ inf$；
2. $1.0\ /\ inf$等于0.0

注：inf是可以与其他浮点数进行比较的，即可以参与<=、>+、==、!=等运算。


### 变量名重命名

使用 `using yourName = typeName` 对变量类型重定义名称，覆盖了 `typedef` 的全部用途，相比于 `typedef` 可读性更高，可定义模板（自适应类型），并且可以同时使用原变量名和新变量名

```cpp
template <typename T>
using vec = vector<T, vector<T>>;
using LL = long long;
```

### 标识符

使用标识符进行调试，可提高调试效率，快速 `禁用 / 启用` 不同功能的代码

```
#define DEBUG // 标识符 
```

#### $Method\ 1 $

`#ifdef` 检查程序中是否有通过 `#define` 定义的对应标识符
如果有定义，就会执行截止到 `#endif` 的语句

```cpp
#ifdef DEBUG
 //do something
#endif
```

#### $Method\ 2$

`#ifndef` 检查是否没有定义相应标识符，如没有定义，则执行截止到 `#endif` 的语句

```cpp
#ifndef DEBUG
 //do something
#endif
```

因此对于以上示例，当定义 `#define DEBUG` 时 $Method\ 1$ 中的语句会执行，而 $Method\ 2$ 中的语句不会执行. 当没有定义 `#define DEBUG` 时 $Method\ 1$ 中的语句不会执行，而 $Method\ 2$ 中的语句会执行. 

#### 系统标识符

另外，当在不同操作系统下编译时，编译器会自动传入系统标识符，如：

1. `__WINDOWS__`（$Windows$ 下 gcc 编译器自动传入）
2. `__LINUX__`（$Linux$ 下 gcc 编译器自动传入）

通过系统标识符，我们可以根据操作系统的不同选择不同语句，如自动选择未锁定 `getchar`：

```cpp
#ifdef __LINUX__
#define getchar() getchar_unlocked()
#define putchar(a) putchar_unlocked(a)
#endif

#ifdef __WINDOWS__
#define getchar() _getchar_nolock()
#define putchar(a) _putchar_nolock()
#endif
```