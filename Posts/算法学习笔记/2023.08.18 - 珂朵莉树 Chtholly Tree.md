# 珂朵莉树 $Chtholly\ Tree$

珂朵莉树是由 [$\color{#ff8c00}{\mathbf{ODT}}$](https://codeforces.com/profile/ODT) 在 [Codeforces Round #449](https://codeforces.com/contest/896) 的题解中发明的一种数据结构, 或者说是做法, 因为它事实上是一系列基于 $\rm set$ 实现维护区间信息的操作. 仅适用于随机数据, 并且随机数据下实际运行效率不错. 

### 珂朵莉树能解决的问题

事实上, 珂朵莉树维护的是若干值相同的区间连续段, 对于具有区间推平类似的操作 (如区间赋值), 同时夹杂其他操作如区间加, 求区间第 $k$ 小 (可重), 询问区间每个数字的 $x$ 次方的和等, 并且数据随机的情况, 都能很好地应用珂朵莉树. 

### 算法思想

既然有对一段区间赋值的操作, 那么考虑维护若干值相同的连续区间: 

```cpp
struct Range {
	int l, r; // 段首段尾 
	mutable LL val; // 段值 
	Range(int l, int r = 0, LL val = 0) : l(l), r(r), val(val) {}
	bool operator < (const Range &t) const { return l < t.l; }
};
```

初始时将序列的每个元素视为一个区间插入 $\rm set$. 

注意这里定义 $val$ 变量为 $\rm mutable$ 类型.  $\rm mutable$ 关键字表示可修改的常量, 由于 $\rm set$ 迭代器是常量迭代器, 无法对它指向的值进行修改, 因此需要添加 $\rm mutable$ 关键字修饰. 

重载完运算符后, 我们将所有区间信息插入 $\rm set$, 即将每个区间按左端点排序, 得到了整个序列. 

#### 核心操作: 分裂区间

当区间赋值的操作覆盖到了某个区间段的一部分, 就需要将原区间分裂, 函数内传入 $pos$ 参数, 表示将该区间拆分成 $[l, pos - 1]$ 与 $[pos, r]$ 两部分. 

先将 $it$ 迭代器指向包含 $pos$ 的区间, 修改该区间的 $l, r$ 即可. 

```cpp
set<Range>::iterator split(int pos) {
	it = lower_bound(st.begin(), st.end(), Range(pos));
	// 找到左端点大于等于 pos 的第一个区间 
	if (it != st.end() and it->l == pos) return it;
	// pos 为该区间的左端点, 直接返回该区间即可 
	-- it;
	// 将 it 移动到包含 pos 的区间 
	if (it->r < pos) return st.end(); // 没有区间包含 pos 
	int l = it->l, r = it->r; LL val = it->val;
	st.erase(it);
	st.insert((Range){l, pos - 1, val});
	// 修改区间值, 重新插入 set
	return st.insert((Range){pos, r, val}).first;
}
```

注意这里的一个压行 $\rm Trick$: $\rm set$ 的 $\rm insert$ 函数返回一个二元组 $\rm pair$. 第一个关键字为插入位置的迭代器, 第二个关键字为是否插入成功的 $\rm bool$ 值. 

### 合并区间

```cpp
void merge(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	st.erase(itl, itr);
	st.insert((Range){l, r, val});
}
```

### 修改区间值

```cpp
void modify(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i) i->val += val;
}
```

```cpp
LL rk(int l, int r, int k) {
	vector<Save> a;
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i)
		a.push_back((Save){i->r - i->l + 1, i->val});
	sort(a.begin(), a.end());
	for (auto t : a) {
		if (k <= t.len) return t.val;
		else k -= t.len;
	}
}
```


时间复杂度 $O(n \cdot \log \log n)$