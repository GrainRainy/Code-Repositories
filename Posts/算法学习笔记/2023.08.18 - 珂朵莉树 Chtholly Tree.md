# 珂朵莉树 $Chtholly\ Tree$

珂朵莉树是由 [$\color{#ff8c00}{\mathbf{ODT}}$](https://codeforces.com/profile/ODT) 在 [Codeforces Round #449](https://codeforces.com/contest/896) 的题解中发明的一种数据结构, 或者说是做法, 因为它事实上是一系列基于 $\rm set$ 实现维护区间信息的操作. 仅适用于随机数据, 并且随机数据下实际运行效率不错. 

## [模板题](https://codeforces.com/problemset/problem/896/C)

### 简化题意

要求实现若干操作: 

区间加, 区间赋值, 区间第 $k$ 小 (可重), 询问区间每个数字的 $x$ 次方的和. 

### $Solutions$



时间复杂度 $O(n \cdot \log\log n)$

```cpp
struct Range {
	int l, r; 
	mutable LL val;
	Range(int l, int r = 0, LL val = 0) : l(l), r(r), val(val) {}
	bool operator < (const Range &t) const { return l < t.l; }
};
struct Save {
	int len; LL val;
	bool operator < (const Save &t) const { return val < t.val; }
};
set<Range> st;
set<Range>::iterator it, itl, itr;
```

```cpp
set<Range>::iterator split(int pos) {
	it = lower_bound(st.begin(), st.end(), Range(pos));
	if (it != st.end() and it->l == pos) return it;
	-- it;
	if (it->r < pos) return st.end();
	int l = it->l, r = it->r; LL val = it->val;
	st.erase(it);
	st.insert((Range){l, pos - 1, val});
	return st.insert((Range){pos, r, val}).first;
}
```

```cpp
void merge(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	st.erase(itl, itr);
	st.insert((Range){l, r, val});
}
```

```cpp
void modify(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i) i->val += val;
}
```

```cpp
LL rk(int l, int r, int k) {
	vector<Save> a;
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i)
		a.push_back((Save){i->r - i->l + 1, i->val});
	sort(a.begin(), a.end());
	for (auto t : a) {
		if (k <= t.len) return t.val;
		else k -= t.len;
	}
}
```

```cpp
int rpow(int l, int r, int x, int y) {
	int res = 0;
	set<Range>::iterator itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i)
		upd(res, (LL)qpow(i->val, x, y) * (i->r - i->l + 1) % y, y);
	return res;
}
```

### 珂朵莉树能解决的其他问题

事实上, 对于具有区间推平类似的操作 (如区间赋值)