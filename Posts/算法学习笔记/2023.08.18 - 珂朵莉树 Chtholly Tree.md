# 珂朵莉树 $Chtholly\ Tree$

珂朵莉树是由 [$\color{#ff8c00}{\mathbf{ODT}}$](https://codeforces.com/profile/ODT) 在 [Codeforces Round #449](https://codeforces.com/contest/896) 的题解中发明的一种数据结构, 或者说是做法, 因为它事实上是一系列基于 $\rm set$ 实现维护区间信息的操作. 仅适用于随机数据, 并且随机数据下实际运行效率不错. 

### 珂朵莉树能解决的问题

事实上, 珂朵莉树维护的是若干值相同的区间连续段, 对于具有区间推平类似的操作 (如区间赋值), 同时夹杂其他操作如区间加, 求区间第 $k$ 小 (可重), 询问区间每个数字的 $x$ 次方的和等, 并且数据随机的情况, 都能很好地应用珂朵莉树. 


### 算法思想

既然有对一段区间赋值的操作, 那么考虑维护若干值相同的连续区间: 

```cpp
struct Range {
	int l, r; // 段首段尾 
	mutable LL val; // 段值 
	Range(int l, int r = 0, LL val = 0) : l(l), r(r), val(val) {}
	bool operator < (const Range &t) const { return l < t.l; }
};
```

注意由于我们需要动态修改区间值, 因此对 $val$ 的声明需要加 $\rm mutable$ 关键字表示可修改的常量. 

重载完运算符后, 我们将所有区间信息插入 $\rm set$, 即将每个区间按左端点排序, 得到了整个序列. 

```cpp
struct Save {
	int len; LL val;
	bool operator < (const Save &t) const { return val < t.val; }
};
set<Range> st;
set<Range>::iterator it, itl, itr;
```



```cpp
set<Range>::iterator split(int pos) {
	it = lower_bound(st.begin(), st.end(), Range(pos));
	if (it != st.end() and it->l == pos) return it;
	-- it;
	if (it->r < pos) return st.end();
	int l = it->l, r = it->r; LL val = it->val;
	st.erase(it);
	st.insert((Range){l, pos - 1, val});
	return st.insert((Range){pos, r, val}).first;
}
```

```cpp
void merge(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	st.erase(itl, itr);
	st.insert((Range){l, r, val});
}
```

```cpp
void modify(int l, int r, int val) {
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i) i->val += val;
}
```

```cpp
LL rk(int l, int r, int k) {
	vector<Save> a;
	itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i)
		a.push_back((Save){i->r - i->l + 1, i->val});
	sort(a.begin(), a.end());
	for (auto t : a) {
		if (k <= t.len) return t.val;
		else k -= t.len;
	}
}
```

```cpp
int rpow(int l, int r, int x, int y) {
	int res = 0;
	set<Range>::iterator itr = split(r + 1), itl = split(l);
	for (auto i = itl; i != itr; ++ i)
		upd(res, (LL)qpow(i->val, x, y) * (i->r - i->l + 1) % y, y);
	return res;
}
```

时间复杂度 $O(n \cdot \log \log n)$