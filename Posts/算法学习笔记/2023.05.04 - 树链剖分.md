# 树链剖分 $Tree\ Chain\ Partitioning$

## 重链剖分

初始化复杂度 $O(n \cdot logn)$
询问复杂度 $O(q \cdot log^2n)$
常数较小

```cpp
int dep[N], fa[N], nw[N], siz[N], hs[N];
int stamp, dfn[N], top[N];
// top refers to the top point of the chain 
// Note: especially refers to the heavy son 
// cutting trees 

void dfs1(int u, int father) {
	dep[u] = dep[father] + 1, fa[u] = father, siz[u] = 1;
	for (int i = head[u]; ~i; i = edge[i].nxt) {
		int j = edge[i].to;
		if (j == father) continue;
		dfs1(j, u);
		siz[u] += siz[j];
		if (siz[j] > siz[hs[u]]) hs[u] = j;
	}
}

void dfs2(int u, int t) {
	dfn[u] = ++ stamp, nw[stamp] = w[u], top[u] = t;
	if (!hs[u]) return;
	dfs(hs[u], t);
	for (int i = head[u], j; ~i; i = edge[i].nxt) {
		j = edge[i].to;
		if (!top[j]) dfs(j, j);
	}
}
```

除此之外, 当需要对边权进行处理时, 仅需要将一条边的边权下放至深度较深的点, 作为点权处理, 跳过修改两点的 $lca$ 即可. 

具体地, 在 $dfs1$ 中先将输入的边权 `edge[i].w` 赋给连向的点 $j$：`tmpw[j] = edge[i].w;`. 再在 $dfs2$ 中为线段树节点赋值 `nw[dfn[u]] = tmpw[u]`

因此 `while` 循环以内的修改和查询正常操作, 循环之外的点需要进行以下操作：

```cpp
modify(1, dfn[v] + 1, dfn[u], k); // 不对 lca 进行修改和查询 
query(1, dfn[v] + 1, dfn[u]);
```

注意：循环内的 `modify` 与 `query` 函数不做更改

## 经典模型

### 树上 $k$ 级祖先：[树上 $k$ 级祖先](https://www.luogu.com.cn/problem/P5903)：

重链剖分, 倍增跳

```cpp
int find(int x, int k) {
	while (k >= dfn[x] - dfn[top[x]] + 1 and x != root) {
		k -= dfn[x] - dfn[top[x]] + 1;
		x = fa[top[x]];
	}
	return id[dfn[x] - k];
}
```

## 长链剖分

```cpp

```