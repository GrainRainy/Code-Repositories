# 图论杂项

# 最短路进阶

包含同余最短路, 分层最短路和一些最短路神题. 

## 同余最短路

时间复杂度瓶颈在最短路算法

选最小的一个数作为模数来降低复杂度

### 还在写同余最短路？感觉不如转圈！

## 分层最短路

分层即可. 

[$\rm Luogu\ P4568$ - 飞行路线](https://www.luogu.com.cn/problem/P4568)

## 欧拉环游序

新的树上问题转序列问题的方式. 

举例: 多组询问求树上路径抑或和. 

普通 dfs, 每次进入该点和回溯到该点都将该点加入序列, 得到长度为 $2n$ 的序列. 

并且得到的该序列, 如果将一个点第一次出现视为左括号, 

## 三元环计数

给定一张无向图. 求图中有多少无序三元组 $(x, y, z)$ 满足在 $(x, y), (y, z), (z, x)$ 之间的边. 




## 2-SAT

$\rm SAT$, 即 $\rm Satisfiability$ (可满足性). 问题形式为给定若干限制, 例如对于 $x, y, z$ 三个取值为 $\{ 0, 1 \}$ 的元素, 有三个限制形如: 

1. $x = 0 \vee b = 1 \vee c = 0$. 
2. $x = 1 \vee b = 1 \vee c = 0$. 
3. $x = 0 \vee b = 0 \vee c = 1$. 

(注: $ \vee $ 为逻辑或)

要求为 $x, y, z$ 赋值使所有限制满足至少一个条件. 

以上所举例的问题即为 $\rm 3-SAT$ 问题, 是一个经典的 $\rm NPC$ 问题. 

目前多项式时间内可解的 $\rm SAT$ 问题只有 $\rm 2-SAT$, 即每个限制只有两个条件. 形如: 

1. $x = 0 \vee y = 0$. 
2. $x = 1 \vee y = 0$. 

### [模板题](https://www.luogu.com.cn/problem/P4782)

题目给定 $n$ 个元素和若干四元组 $(x, a, y, b)$, 表示 $x = a \vee y = b$, 要求为所有元素指定 $\{ 0, 1 \}$ 权值使得满足所有条件. 

### 建立图论模型

发现如果 $x = \neg a$ 则一定有 $y = b$, 反之同理. 考虑建立图论模型, 将每个点拆成 $0$ 和 $1$ 两个点, 对于每个限制 $x = a \vee y = b$, 转化为两条有向边 $x = \neg a \rightarrow y = b$, $y = \neg b \rightarrow x = a$, 表示当 $x = \neg a$ 能唯一确定 $y$ 的值为 $b$, 反之同理. 

```cpp
for (int i = 1, a, b, c, d; i <= m; ++ i) {
    rd(a), rd(b), rd(c), rd(d);
    add(a + n * b, c + n * (d ^ 1));
    add(c + n * d, a + n * (b ^ 1));
}
```

### 判无解及构造可行解

注意上文中所说的有向边的意义, 由此考虑如何判断无解. 发现如果同一个元素的 $0$ 点与 $1$ 点在同一个强连通分量内, 说明无论该元素取何值都会推出该元素取相反的值, 即无解. 

考虑构造合法解. 当某个元素的 $1$ 点拓扑序在 $0$ 点之前, 说明该元素取 $1$ 时能推出该元素为 $0$, 因此将该元素赋值为 $0$ 即可. 

```cpp
for (int i = 1; i <= n << 1; ++ i) if (!dfn[i]) tarjan(i);
for (int i = 1; i <= n; ++ i)
    if (id[i] == id[i + n]) return puts("IMPOSSIBLE") & 0;
puts("POSSIBLE");
for (int i = 1; i <= n; ++ i) putchar('0' + (id[i] < id[i + n])), putchar(' ');
```

## $\text{Prufer}$ 序列

对于一棵 $n$ 个节点的标定树[^1] ( $n \geqslant 2$ ), 定义它的 $\text{Purfer}$ 序列为: 

每次选择叶子节点中标号最小的一个, 将其删去, 并在 $\text{Prufer}$ 序列中加入它的父节点. 

不难发现, 对于一棵 $n$ 个节点的树, 他的 $\text{Prufer}$ 序列长度为 $n - 2$. 

$\text{Prufer}$ 序列常用来解决生成树问题. 

### 建立 $\text{Prufer}$ 序列

#### $O(n \cdot \log n)$ 构建

做法显然, 维护以节点编号为关键字排序的叶节点小根堆即可. 

#### $O(n)$ 构建



### 性质

[^1]: 标定树指树中每个节点都有一个 $[1, n]$ 且互不相同的序号. 