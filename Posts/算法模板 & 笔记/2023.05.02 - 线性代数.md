# 线性代数

## 矩阵

### 矩阵乘法

矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。

设 $A$ 为 $P \times M$ 的矩阵，$B$ 为 $M \times Q$ 的矩阵，设矩阵 $C$ 为矩阵 $A$ 与 $B 的乘积，

其中矩阵 $C$ 中的第 $i$ 行第 $j$ 列元素可以表示为：

$$C_{i,j} = \sum_{k=1}^MA_{i,k}B_{k,j}$$

注意矩阵乘法不满足乘法交换律


### 矩阵封装类 `Matrix`

```cpp
struct Matrix {
	ULL a[N][N], mx, my;
	
	ULL* operator [](int x) { return a[x]; }
    // 重载数组指针，可直接使用结构体名访问 a[i][j]
	Matrix(int n, int m) { 
		mx = n, my = m;
		memset(a, 0, sizeof a); 
	} // matrix initialization
	
	inline void build() { // construct identity matrix 
	// !! Square Matrix Only !!
		for (int i = 1; i <= mx; i ++) a[i][i] = 1;
	}
	
	Matrix operator * (Matrix b) { // matrix multiplication
		Matrix ans(mx, b.my);
		for (int i = 1; i <= mx; i ++) {
			for (int k = 1; k <= my; k ++) {
				for (int j = 1; j <= b.my; j ++) {
					ans[i][j] = (ans[i][j] +  a[i][k] * b[k][j] % MOD) % MOD;
				}
			}	
		}
		return ans;
	}

	Matrix operator + (Matrix b) { // matrix addition 
		Matrix ans(mx, my);
		for (int i = 1; i <= mx; i ++) {
				for (int j = 1; j <= my; j ++) {
					ans[i][j] = (a[i][j] + b[i][j]) % MOD;
				}
			}
		return ans;
	}
	
	void print() { // output matrix 
		for (int i = 1; i <= mx; i ++, puts("")) 
			for (int j = 1; j <= my; j ++) output(a[i][j]);
	}
};
```

定义时需要传入行列信息：`Matrix a(x, y), b(x, y);`

### 矩阵快速幂

重载运算符 `*` 之后，直接按照整数快速幂写即可，需要注意的是模数在运算符重载那里更改 

```cpp
Matrix fpow(Matrix a, LL k) 
	Matrix ans(a.mx, a.my); 
	ans.build(); // Square Matrix 
	while (k) {!
		if (k & 1) ans = ans * a;
		a = a * a;
		k >>= 1;
	}
	return ans;


fpow(a, k).print(n);
```

## $Gauss$ 消元法

### 高斯消元解线性方程组

```cpp
int Gauss() { // 返回解的个数
	int c, r; // column and row 
	for (c = 1, r = 1; c <= n; c ++){
		int pivot = r;
		for (int i = r; i <= n; i ++) {
			if (fabs(coe[i][c]) > fabs(coe[pivot][c]))
				pivot = i;
		}
		if (fabs(coe[pivot][c]) < EPS) continue;
		swap(coe[pivot], coe[r]);
		
		for (int i = n + 1; i >= c; i --) coe[r][i] /= coe[r][c];
		for (int i = r + 1; i <= n; i ++) {
			if (fabs(coe[i][c]) > EPS){
				for (int j = n + 1; j >= c; j --) 
					coe[i][j] -= coe[r][j] * coe[i][c];
			}
		}
		r ++;
	}
	// calculate coefficient  
	if (r <= n) {
		for (int i = r; i <= n; i ++) {
			if (fabs(coe[i][n + 1]) > EPS) return 0; // No Solutions. 
		}
		return 2; // Many Solutions. 
	}
	// special judgements 
	
	for (int i = n; i >= 1; i --) {
		for (int j = i + 1; j <= n; j ++)
			coe[i][n + 1] -= coe[i][j] * coe[j][n + 1];
	}
	// calculate answers
	return 1; // Only One Solution. 
}

int type = Gauss();
if (type == 0) return puts("No solution"), 0;
if (type == 2) return puts("Infinite group solutions"), 0;
else {
	for (int i = 1; i <= n; i ++){
		if (fabs(coe[i][n + 1]) < EPS) coe[i][n + 1] = 0; // 防止输出 -0
		printf("%.2lf\n", coe[i][n + 1]);
	}
}
```

### $Gauss$ 消元解线性异或方程组

```cpp
bitset<N> a[N];
int Gauss() { // return value is the number of solutions  
	int r, c;
	for (r = c = 1; c <= n; c ++) {
		int pivot = r;
		for (int i = r + 1; i <= n; i ++)
			if (a[i][c]){ pivot = i; break; }
		if (!a[pivot][c]) continue;
		swap(a[pivot], a[r]);
		
		for (int i = r + 1; i <= n; i ++) {
			if (a[i][c]) a[i] ^= a[r];
		}
		r ++;
	}
	
	if (r <= n) {
		for (int i = r; i <= n; i ++)
			if (a[i][n + 1]) return 0;
		return 2;
	}

	for (int i = n; i >= 1; i --) {
		for (int j = i + 1; j <= n; j ++)
			a[i][n + 1] = a[i][n + 1] ^ a[i][j] * a[j][n + 1];  
	}
	return 1;
}
```